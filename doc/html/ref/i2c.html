<!-- Copyright (C) 2009 Free Software Foundation, Inc.                                -->
<!-- This material may be distributed only subject to the terms      -->
<!-- and conditions set forth in the Open Publication License, v1.0  -->
<!-- or later (the latest version is presently available at          -->
<!-- http://www.opencontent.org/openpub/).                           -->
<!-- Distribution of the work or derivative of the work in any       -->
<!-- standard (paper) book form is prohibited unless prior           -->
<!-- permission is obtained from the copyright holder.               -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Overview</TITLE
><meta name="MSSmartTagsPreventParsing" content="TRUE">
<META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="eCos Reference Manual"
HREF="ecos-ref.html"><LINK
REL="UP"
TITLE="I2C Support"
HREF="io-i2c.html"><LINK
REL="PREVIOUS"
TITLE="I2C Support"
HREF="io-i2c.html"><LINK
REL="NEXT"
TITLE="I2C Interface"
HREF="i2c-api.html"></HEAD
><BODY
CLASS="REFENTRY"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>eCos Reference Manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="io-i2c.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="i2c-api.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="I2C"
></A
>Overview</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8568"
></A
><H2
>Name</H2
>Overview&nbsp;--&nbsp;eCos Support for I2C, the Inter IC Bus</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="I2C-DESCRIPTION"
></A
><H2
>Description</H2
><P
>The Inter IC Bus (I2C) is one of a number of serial bus technologies.
It can be used to connect a processor to one or more peripheral chips,
for example analog-to-digital convertors or real time clocks, using
only a small number of pins and PCB tracks. The technology was
originally developed by Philips Semiconductors but is supported by
many other vendors. The bus specification is freely available.
    </P
><P
>In a typical I2C system the processor acts as the I2C bus master. The
peripheral chips act as slaves. The bus consists of just two wires:
SCL carries a clock signal generated by the master, and SDA is a
bi-directional data line. The normal clock frequency is 100KHz. Each
slave has a 7-bit address. With some chips the address is hard-wired,
and it is impossible to have two of these chips on the same bus. With
other chips it is possible to choose between one of a small number of
addresses by connecting spare pins to either VDD or GND.
    </P
><P
>An I2C data transfer involves a number of stages:
    </P
><P
></P
><OL
TYPE="1"
><LI
><P
>The bus master generates a start condition, a high-to-low transition
on the SDA line while SCL is kept high. This signalling cannot occur
during data transfer.
      </P
></LI
><LI
><P
>The bus master clocks the 7-bit slave address onto the SDA line,
followed by a direction bit to distinguish between reads and writes.
      </P
></LI
><LI
><P
>The addressed device acknowledges. If the master does not see an
acknowledgement then this suggests it is using the wrong address for
the slave device.
      </P
></LI
><LI
><P
>If the master is transmitting data to the slave then it will send this
data one byte at a time. The slave acknowledges each byte. If the
slave is unable to accept more data, for example because it has run
out of buffer space, then it will generate a nack and the master
should stop sending.
      </P
></LI
><LI
><P
>If the master is receiving data from the slave then the slave will
send this data one byte at a time. The master should acknowledge each
byte, until the last one. When the master has received all the data it
wants it should generate a nack and the slave will stop sending. This
nack is essential because it causes the slave to stop driving the SDA
line, releasing it back to the master.
      </P
></LI
><LI
><P
>It is possible to switch direction in a single transfer, using what is
known as a repeated start. This involves generating another start
condition, sending the 7-bit address again, followed by a new
direction bit.
      </P
></LI
><LI
><P
>At the end of a transfer the master should generate a stop condition,
a low-to-high transition on the SDA line while SCL is kept high. Again
this signalling does not occur at other times.
      </P
></LI
></OL
><P
>There are a number of extensions. The I2C bus supports multiple bus
masters and there is an arbitration procedure to allow a master to
claim the bus. Some devices can have 10-bit addresses rather than
7-bit addresses. There is a fast mode operating at 400KHz instead of
the usual 100KHz, and a high-speed mode operating at 3.4MHz. Currently
most I2C-based systems do not involve any of these extensions.
    </P
><P
>At the hardware level I2C bus master support can be implemented in one
of two ways. Some processors provide a dedicated I2C device, with the
hardware performing much of the work. On other processors the I2C
device is implemented in software, by bit-banging some GPIO pins. The
latter approach can consume a significant number of cpu cycles, but is
often acceptable because only occasional access to the I2C devices is
needed.
    </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="I2C-ECOS-IMPLEMENTATION"
></A
><H2
>eCos Support for I2C</H2
><P
>The eCos I2C support for any given platform is spread over a number of
different packages:
    </P
><P
></P
><UL
><LI
><P
>This package, <CODE
CLASS="VARNAME"
>CYGPKG_IO_I2C</CODE
>, exports a generic API
for accessing devices attached to an I2C bus. This API handles issues
such as locking between threads. The package does not contain any
hardware-specific code. Instead it will use a separate I2C bus driver
to handle the hardware, and it defines the interface that such bus
drivers should provide. The package only provides support for a bus
master, not for acting as a slave device.
      </P
><P
><CODE
CLASS="VARNAME"
>CYGPKG_IO_I2C</CODE
> also provides the
hardware-independent portion of a bit-banged bus implementation. This
needs to be complemented by a hardware-specific function that actually
manipulates the SDA and SCL lines.
      </P
></LI
><LI
><P
>If the processor has a dedicated I2C device then there will be a bus
driver package for that hardware. The processor may be used on
many different platforms and the same bus driver can be used on each one.
The actual I2C devices attached to the bus will vary from one platform to
the next.
      </P
></LI
><LI
><P
>The generic API depends on <CODE
CLASS="STRUCTNAME"
>cyg_i2c_device</CODE
>
data structures. These contain the information needed by a bus driver,
for example the device address. Usually the data structures are
provided by the platform HAL since it is that package which knows
about all the devices on the platform.
      </P
><P
>On some development boards the I2C lines are brought out to expansion
connectors, allowing end users to add extra devices. In such cases the
platform HAL may not know about all the devices on the board. Data
structures for the additional devices can instead be supplied by
application code.
      </P
></LI
><LI
><P
>If the board uses a bit-banged bus then typically the platform HAL
will also instantiate the bus instance, providing the function that
handles the low-level SDA and SCL manipulation. Usually this code
cannot be shared because each board may use different GPIO pins for
driving SCL and SDA, so the code belongs in the platform HAL rather
than in a separate package.
      </P
></LI
><LI
><P
>Some types of I2C devices may have their own driver package. For
example a common type of I2C device is a battery-backed wallclock, and
eCos defines how these devices should be supported. Such an I2C device
will have its own wallclock device driver and the device will not be
accessed directly by application code. For other types of device eCos
does not define an API and there will not be separate device driver
packages. Instead application code is expected to use the
<CODE
CLASS="STRUCTNAME"
>cyg_i2c_device</CODE
> structures directly to access
the hardware.
      </P
></LI
></UL
><P
>Typically all appropriate packages will be loaded automatically when
you configure eCos for a given platform. If the application does not use
any of the I2C I/O facilities, directly or indirectly, then linker
garbage collection should eliminate all unnecessary code and data. All
necessary initialization should happen automatically. However the
exact details may depend on the platform, so the platform HAL
documentation should be checked for further details.
    </P
><P
>There is one important exception to this: if the I2C devices are
attached to an expansion connector then the platform HAL will not know
about these devices. Instead more work will have to be done by
application code.
    </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="io-i2c.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ecos-ref.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="i2c-api.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>I2C Support</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="io-i2c.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>I2C Interface</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>