<!-- Copyright (C) 2009 Free Software Foundation, Inc.                                -->
<!-- This material may be distributed only subject to the terms      -->
<!-- and conditions set forth in the Open Publication License, v1.0  -->
<!-- or later (the latest version is presently available at          -->
<!-- http://www.opencontent.org/openpub/).                           -->
<!-- Distribution of the work or derivative of the work in any       -->
<!-- standard (paper) book form is prohibited unless prior           -->
<!-- permission is obtained from the copyright holder.               -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Interrupt Handling</TITLE
><meta name="MSSmartTagsPreventParsing" content="TRUE">
<META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="eCos Reference Manual"
HREF="ecos-ref.html"><LINK
REL="UP"
TITLE="HAL Interfaces"
HREF="hal-interfaces.html"><LINK
REL="PREVIOUS"
TITLE="Architecture Characterization"
HREF="hal-architecture-characterization.html"><LINK
REL="NEXT"
TITLE="Clocks and Timers"
HREF="hal-clocks-and-timers.html"></HEAD
><BODY
CLASS="SECTION"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>eCos Reference Manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="hal-architecture-characterization.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 4. HAL Interfaces</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="hal-clocks-and-timers.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECTION"
><H1
CLASS="SECTION"
><A
NAME="HAL-INTERRUPT-HANDLING"
>Interrupt Handling</A
></H1
><P
>These interfaces contain definitions related to interrupt
handling. They include definitions of exception and interrupt numbers,
interrupt enabling and masking.</P
><P
>These definitions are normally found in
<TT
CLASS="FILENAME"
>cyg/hal/hal_intr.h</TT
>.  This file is supplied by the
architecture HAL.  Any variant or platform specific definitions will
be found in <TT
CLASS="FILENAME"
>cyg/hal/var_intr.h</TT
>,
<TT
CLASS="FILENAME"
>cyg/hal/plf_intr.h</TT
> or
<TT
CLASS="FILENAME"
>cyg/hal/hal_platform_ints.h</TT
> in the variant or platform
HAL, depending on the exact target. These files are include
automatically by this header, so need not be included explicitly.</P
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="AEN2721"
>Vector numbers</A
></H2
><TABLE
BORDER="5"
BGCOLOR="#E0E0F0"
WIDTH="70%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>CYGNUM_HAL_VECTOR_XXXX
CYGNUM_HAL_VSR_MIN
CYGNUM_HAL_VSR_MAX
CYGNUM_HAL_VSR_COUNT

CYGNUM_HAL_INTERRUPT_XXXX
CYGNUM_HAL_ISR_MIN
CYGNUM_HAL_ISR_MAX
CYGNUM_HAL_ISR_COUNT

CYGNUM_HAL_EXCEPTION_XXXX
CYGNUM_HAL_EXCEPTION_MIN
CYGNUM_HAL_EXCEPTION_MAX
CYGNUM_HAL_EXCEPTION_COUNT</PRE
></TD
></TR
></TABLE
><P
>All possible VSR, interrupt and exception vectors are specified here,
together with maximum and minimum values for range checking. While the
VSR and exception numbers will be defined in this file, the interrupt
numbers will normally be defined in the variant or platform HAL file
that is included by this header. </P
><P
>There are two ranges of numbers, those for the vector service
routines and those for the interrupt service routines. The relationship
between these two ranges is undefined, and no equivalence should
be assumed if vectors from the two ranges coincide.</P
><P
>The VSR vectors correspond to the set of exception vectors that can be
delivered by the CPU architecture, many of these will be internal
exception traps. The ISR vectors correspond to the set of external
interrupts that can be delivered and are usually determined by extra
decoding of the interrupt controller by the interrupt VSR.</P
><P
>Where a CPU supports synchronous exceptions, the range of such
exceptions allowed are defined by <TT
CLASS="LITERAL"
>CYGNUM_HAL_EXCEPTION_MIN</TT
> and
<TT
CLASS="LITERAL"
>CYGNUM_HAL_EXCEPTION_MAX</TT
>. The
<TT
CLASS="LITERAL"
>CYGNUM_HAL_EXCEPTION_XXXX</TT
> definitions are
standard names used by target independent code to test for the
presence of particular exceptions in the architecture. The actual
exception numbers will normally correspond to the VSR exception
range. In future other exceptions generated by the system software
(such as stack overflow) may be added.</P
><P
><TT
CLASS="LITERAL"
>CYGNUM_HAL_ISR_COUNT</TT
>, <TT
CLASS="LITERAL"
>CYGNUM_HAL_VSR_COUNT</TT
> and
<TT
CLASS="LITERAL"
>CYGNUM_HAL_EXCEPTION_COUNT</TT
> define the number of
ISRs, VSRs and EXCEPTIONs respectively for the purposes of defining
arrays etc. There might be a translation from the supplied vector
numbers into array offsets. Hence
<TT
CLASS="LITERAL"
>CYGNUM_HAL_XXX_COUNT</TT
> may not simply be
<TT
CLASS="LITERAL"
>CYGNUM_HAL_XXX_MAX</TT
> - <TT
CLASS="LITERAL"
>CYGNUM_HAL_XXX_MIN</TT
> or <TT
CLASS="LITERAL"
>CYGNUM_HAL_XXX_MAX</TT
>&#0043;1.</P
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="AEN2739"
>Interrupt state control</A
></H2
><TABLE
BORDER="5"
BGCOLOR="#E0E0F0"
WIDTH="70%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>CYG_INTERRUPT_STATE
HAL_DISABLE_INTERRUPTS( old )
HAL_RESTORE_INTERRUPTS( old )
HAL_ENABLE_INTERRUPTS()
HAL_QUERY_INTERRUPTS( state )</PRE
></TD
></TR
></TABLE
><P
>These macros provide control over the state of the CPUs interrupt mask
mechanism. They should normally manipulate a CPU status register to
enable and disable interrupt delivery. They should not access an
interrupt controller.</P
><P
><TT
CLASS="LITERAL"
>CYG_INTERRUPT_STATE</TT
> is a data type that should be
used to store the interrupt state returned by
<CODE
CLASS="FUNCTION"
>HAL_DISABLE_INTERRUPTS()</CODE
> and
<CODE
CLASS="FUNCTION"
>HAL_QUERY_INTERRUPTS()</CODE
> and passed to
<CODE
CLASS="FUNCTION"
>HAL_RESTORE_INTERRUPTS()</CODE
>.</P
><P
><CODE
CLASS="FUNCTION"
>HAL_DISABLE_INTERRUPTS()</CODE
> disables the delivery of
interrupts and stores the original state of the interrupt mask in the
variable passed in the <CODE
CLASS="PARAMETER"
>old</CODE
> argument.</P
><P
><CODE
CLASS="FUNCTION"
>HAL_RESTORE_INTERRUPTS()</CODE
> restores the state of
the interrupt mask to that recorded in <CODE
CLASS="PARAMETER"
>old</CODE
>.</P
><P
><CODE
CLASS="FUNCTION"
>HAL_ENABLE_INTERRUPTS()</CODE
> simply enables interrupts
regardless of the current state of the mask.</P
><P
><CODE
CLASS="FUNCTION"
>HAL_QUERY_INTERRUPTS()</CODE
> stores the state of the
interrupt mask in the variable passed in the <CODE
CLASS="PARAMETER"
>state</CODE
> argument. The state stored here should also be
capable of being passed to
<CODE
CLASS="FUNCTION"
>HAL_RESTORE_INTERRUPTS()</CODE
> at a later point.</P
><P
>It is at the HAL implementer&#8217;s discretion exactly
which interrupts are masked by this mechanism. Where a CPU has more
than one interrupt type that may be masked separately (e.g. the
ARM's IRQ and FIQ) only those that can raise DSRs need
to be masked here. A separate architecture specific mechanism may
then be used to control the other interrupt types.</P
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="AEN2761"
>ISR and VSR management</A
></H2
><TABLE
BORDER="5"
BGCOLOR="#E0E0F0"
WIDTH="70%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>HAL_INTERRUPT_IN_USE( vector, state )
HAL_INTERRUPT_ATTACH( vector, isr, data, object )
HAL_INTERRUPT_DETACH( vector, isr )
HAL_VSR_SET( vector, vsr, poldvsr )
HAL_VSR_GET( vector, pvsr )
HAL_VSR_SET_TO_ECOS_HANDLER( vector, poldvsr )</PRE
></TD
></TR
></TABLE
><P
>These macros manage the attachment of interrupt and vector service
routines to interrupt and exception vectors respectively.</P
><P
><CODE
CLASS="FUNCTION"
>HAL_INTERRUPT_IN_USE()</CODE
> tests the state of the
supplied interrupt vector and sets the value of the state parameter to
either 1 or 0 depending on whether there is already an ISR attached to
the vector. The HAL will only allow one ISR to be attached to each
vector, so it is a good idea to use this function before using
<CODE
CLASS="FUNCTION"
>HAL_INTERRUPT_ATTACH()</CODE
>.</P
><P
><CODE
CLASS="FUNCTION"
>HAL_INTERRUPT_ATTACH()</CODE
> attaches
the ISR, data pointer and object pointer to the given
<CODE
CLASS="PARAMETER"
>vector</CODE
>. When an interrupt occurs on this
vector the ISR is called using the C calling convention and the vector
number and data pointer are passed to it as the first and second
arguments respectively.</P
><P
><CODE
CLASS="FUNCTION"
>HAL_INTERRUPT_DETACH()</CODE
> detaches the ISR from the
vector.</P
><P
><CODE
CLASS="FUNCTION"
>HAL_VSR_SET()</CODE
> replaces the VSR attached to the
<CODE
CLASS="PARAMETER"
>vector</CODE
> with the replacement supplied in
<CODE
CLASS="PARAMETER"
>vsr</CODE
>. The old VSR is returned in the location
pointed to by <CODE
CLASS="PARAMETER"
>pvsr</CODE
>.</P
><P
><CODE
CLASS="FUNCTION"
>HAL_VSR_GET()</CODE
> assigns
a copy of the VSR to the location pointed to by <CODE
CLASS="PARAMETER"
>pvsr</CODE
>.</P
><P
><CODE
CLASS="FUNCTION"
>HAL_VSR_SET_TO_ECOS_HANDLER()</CODE
> ensures that the
VSR for a specific exception is pointing at the eCos exception VSR and
not one for RedBoot or some other ROM monitor. The default when
running under RedBoot is for exceptions to be handled by RedBoot and
passed to GDB. This macro diverts the exception to eCos so that it may
be handled by application code. The arguments are the VSR vector to be
replaces, and a location in which to store the old VSR pointer, so
that it may be replaced at a later point.</P
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="AEN2783"
>Interrupt controller management</A
></H2
><TABLE
BORDER="5"
BGCOLOR="#E0E0F0"
WIDTH="70%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>HAL_INTERRUPT_MASK( vector )
HAL_INTERRUPT_UNMASK( vector )
HAL_INTERRUPT_ACKNOWLEDGE( vector )
HAL_INTERRUPT_CONFIGURE( vector, level, up )
HAL_INTERRUPT_SET_LEVEL( vector, level )</PRE
></TD
></TR
></TABLE
><P
>These macros exert control over any prioritized interrupt
controller that is present. If no priority controller exists, then
these macros should be empty.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>  These macros may not be reentrant, so care should be taken to
  prevent them being called while interrupts are enabled. This means
  that they can be safely used in initialization code before
  interrupts are enabled, and in ISRs. In DSRs, ASRs and thread code,
  however, interrupts must be disabled before these macros are
  called. Here is an example for use in a DSR where the interrupt
  source is unmasked after data processing:
  </P
><TABLE
BORDER="5"
BGCOLOR="#E0E0F0"
WIDTH="70%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> ...
 HAL_DISABLE_INTERRUPTS(old);
 HAL_INTERRUPT_UNMASK(CYGNUM_HAL_INTERRUPT_ETH);
 HAL_RESTORE_INTERRUPTS(old);
 ...</PRE
></TD
></TR
></TABLE
></BLOCKQUOTE
></DIV
><P
><CODE
CLASS="FUNCTION"
>HAL_INTERRUPT_MASK()</CODE
> causes the interrupt
associated with the given vector to be blocked.</P
><P
><CODE
CLASS="FUNCTION"
>HAL_INTERRUPT_UNMASK()</CODE
> causes the interrupt
associated with the given vector to be unblocked.</P
><P
><CODE
CLASS="FUNCTION"
>HAL_INTERRUPT_ACKNOWLEDGE()</CODE
> acknowledges the
current interrupt from the given vector. This is usually executed from
the ISR for this vector when it is prepared to allow further
interrupts.  Most interrupt controllers need some form of acknowledge
action before the next interrupt is allowed through. Executing this
macro may cause another interrupt to be delivered. Whether this
interrupts the current code depends on the state of the CPU interrupt
mask.</P
><P
><CODE
CLASS="FUNCTION"
>HAL_INTERRUPT_CONFIGURE()</CODE
> provides
control over how an interrupt signal is detected. The arguments
are:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>vector</DT
><DD
><P
>The interrupt vector to be configured.</P
></DD
><DT
>level</DT
><DD
><P
>      Set to <CODE
CLASS="VARNAME"
>true</CODE
> if the interrupt is detected by
      level, and <CODE
CLASS="VARNAME"
>false</CODE
> if it is edge triggered.
      </P
></DD
><DT
>up</DT
><DD
><P
>      If the interrupt is set to level detect, then if this is
      <CODE
CLASS="VARNAME"
>true</CODE
> it is detected by a high signal level,
      and if <CODE
CLASS="VARNAME"
>false</CODE
> by a low signal level. If the
      interrupt is set to edge triggered, then if this is
      <CODE
CLASS="VARNAME"
>true</CODE
> it is triggered by a rising edge and if
      <CODE
CLASS="VARNAME"
>false</CODE
> by a falling edge.
      </P
></DD
></DL
></DIV
><P
><CODE
CLASS="FUNCTION"
>HAL_INTERRUPT_SET_LEVEL()</CODE
> provides control over
the hardware priority of the interrupt. The arguments are:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>vector</DT
><DD
><P
>The interrupt whose level is to be set.</P
></DD
><DT
>level</DT
><DD
><P
>      The priority level to which the interrupt is to set. In some
      architectures the masking of an interrupt is achieved by
      changing its priority level. Hence this function,
      <CODE
CLASS="FUNCTION"
>HAL_INTERRUPT_MASK()</CODE
> and
      <CODE
CLASS="FUNCTION"
>HAL_INTERRUPT_UNMASK()</CODE
> may interfere with
      each other.
      </P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="hal-architecture-characterization.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ecos-ref.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="hal-clocks-and-timers.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Architecture Characterization</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="hal-interfaces.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Clocks and Timers</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>